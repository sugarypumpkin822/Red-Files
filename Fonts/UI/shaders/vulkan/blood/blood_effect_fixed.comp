#version 450 core

// Blood Effect Compute Shader for Vulkan
// Advanced blood simulation and rendering using compute shaders

// Input buffers
layout(binding = 0) readonly buffer BloodParticleBuffer {
    vec4 position;       // Particle position (xyz) and age (w)
    vec4 velocity;       // Particle velocity (xyz) and life (w)
    vec4 color;          // Particle color (rgba)
    vec4 size;           // Particle size (x) and other properties (yzw)
    vec4 properties;      // Particle properties (temperature, viscosity, etc.)
} particles[];

layout(binding = 1) readonly buffer BloodSurfaceBuffer {
    vec4 position;       // Surface position (xyz) and normal (w)
    vec4 velocity;       // Surface velocity (xyz) and wetness (w)
    vec4 color;          // Surface color (rgba)
    vec4 properties;      // Surface properties (thickness, roughness, etc.)
} surfaces[];

layout(binding = 2) readonly buffer BloodEnvironmentBuffer {
    vec4 gravity;        // Gravity vector (xyz) and strength (w)
    vec4 wind;           // Wind vector (xyz) and strength (w)
    vec4 temperature;    // Temperature (xyz) and ambient (w)
    vec4 humidity;       // Humidity (xyz) and pressure (w)
    vec4 lighting;       // Lighting parameters (ambient, diffuse, specular, intensity)
    vec4 time;           // Time parameters (current, delta, total, frame)
} environment[];

// Output buffers
layout(binding = 3) buffer BloodParticleOutputBuffer {
    vec4 position;       // Updated particle position (xyz) and age (w)
    vec4 velocity;       // Updated particle velocity (xyz) and life (w)
    vec4 color;          // Updated particle color (rgba)
    vec4 size;           // Updated particle size (x) and other properties (yzw)
    vec4 properties;      // Updated particle properties (temperature, viscosity, etc.)
} outputParticles[];

layout(binding = 4) buffer BloodSurfaceOutputBuffer {
    vec4 position;       // Updated surface position (xyz) and normal (w)
    vec4 velocity;       // Updated surface velocity (xyz) and wetness (w)
    vec4 color;          // Updated surface color (rgba)
    vec4 properties;      // Updated surface properties (thickness, roughness, etc.)
} outputSurfaces[];

layout(binding = 5) buffer BloodRenderBuffer {
    vec4 color;          // Rendered color (rgba)
    vec4 depth;          // Depth value and other render data
    vec4 normal;         // Normal vector (xyz) and roughness (w)
    vec4 material;       // Material properties (metallic, roughness, etc.)
} renderBuffer[];

// Uniforms
layout(set = 0, binding = 6) uniform BloodEffectUniforms {
    mat4 viewMatrix;
    mat4 projectionMatrix;
    mat4 viewProjectionMatrix;
    mat4 modelMatrix;
    mat4 normalMatrix;
    mat4 inverseViewMatrix;
    mat4 inverseProjectionMatrix;
    mat4 inverseViewProjectionMatrix;
    mat4 shadowMatrix;
    mat4 environmentMatrix;
    vec4 cameraPosition;
    vec4 cameraDirection;
    vec4 cameraUp;
    vec4 cameraRight;
    vec4 lightDirection;
    vec4 lightColor;
    vec4 lightPosition;
    vec4 lightIntensity;
    vec4 ambientColor;
    vec4 bloodColor;
    vec4 bloodProperties;
    vec4 simulationParams;
    vec4 renderingParams;
    vec4 effectParams;
    vec4 animationParams;
    vec4 physicsParams;
    vec4 materialParams;
    vec4 lightingParams;
    vec4 postProcessParams;
    vec4 debugParams;
} uniforms;

// Push constants
layout(push_constant) uniform PushConstants {
    vec4 particleCount;
    vec4 surfaceCount;
    vec4 renderCount;
    vec4 workGroupSize;
    vec4 deltaTime;
    vec4 currentTime;
    vec4 frameCount;
    vec4 simulationStep;
    vec4 renderPass;
    vec4 debugMode;
    vec4 performanceMode;
    vec4 qualityMode;
    vec4 effectMode;
    vec4 animationMode;
    vec4 physicsMode;
    vec4 materialMode;
    vec4 lightingMode;
    vec4 postProcessMode;
    vec4 debugLevel;
} pushConstants;

// Random number generator
float random(vec2 seed)
{
    return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

// Hash function for noise generation
float hash(vec3 p)
{
    p = fract(p * vec3(443.898, 444.263, 444.657));
    p += dot(p, p + 19.19);
    return fract((p.x + p.y) * p.z);
}

// Simplex noise function
float simplexNoise(vec3 p)
{
    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);
    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
    
    // First corner
    vec3 i = floor(p + dot(p, C.yyy));
    vec3 x0 = p - i + dot(i, C.xxx);
    
    // Other corners
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min(g.xyz, l.zxy);
    vec3 i2 = max(g.xyz, l.zxy);
    
    vec3 x1 = x0 - i1 + C.xxx;
    vec3 x2 = x0 - i2 + C.yyy;
    vec3 x3 = x0 - D.yyy;
    
    // Permutations
    i = mod(i, 289.0);
    
    vec4 p_perm = vec4(
        i.x + vec3(0.0, i1.x, 1.0),
        i.y + vec3(0.0, i1.y, 1.0),
        i.z + vec3(0.0, i1.z, 1.0)
    );
    
    float n_ = 1.0 / 7.0;
    vec3 ns = n_ * D.xxy - D.yyy;
    
    vec4 j = p_perm - 49.0 * floor(p_perm * ns.x * ns.x * ns.z);
    
    vec4 x_ = floor(j * ns.x);
    vec4 y_ = floor(j - 7.0 * x_);
    
    vec4 x = x_ * ns.x + ns.yyyy;
    vec4 y = y_ * ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);
    
    vec4 b0 = vec4(x.xy, y.xy);
    vec4 b1 = vec4(x.zw, y.zw);
    
    vec4 s0 = vec4(lessThan(b0, vec4(0.0)));
    vec4 s1 = vec4(lessThan(b1, vec4(0.0)));
    
    vec4 sh = -step(h, vec4(0.0));
    
    vec4 a0 = b0.xzyw + s0.xzyw * sh.xzyw;
    vec4 a1 = b1.xzyw + s1.xzyw * sh.xzyw;
    
    vec3 p0 = vec3(a0.xy, h.x);
    vec3 p1 = vec3(a0.zw, h.y);
    vec3 p2 = vec3(a1.xy, h.z);
    vec3 p3 = vec3(a1.zw, h.w);
    
    vec4 norm = inversesqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;
    
    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
    m = m * m;
    m = m * m;
    vec4 d = vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3));
    
    // Clamp noise to prevent negative values
    d = max(d, 0.0);
    
    float h_val = min(m.x, 1.0);
    
    return 70.0 * dot(d, vec4(1.0)) * h_val;
}

// Fractal noise function
float fractalNoise(vec3 p, int octaves, float frequency, float amplitude)
{
    float value = 0.0;
    float freq = frequency;
    float amp = amplitude;
    
    for (int i = 0; i < octaves; i++)
    {
        value += simplexNoise(p * freq) * amp;
        freq *= 2.0;
        amp *= 0.5;
    }
    
    return value;
}

// Turbulence function
float turbulence(vec3 p, int octaves, float frequency, float amplitude)
{
    float value = 0.0;
    float freq = frequency;
    float amp = amplitude;
    
    for (int i = 0; i < octaves; i++)
    {
        value += abs(simplexNoise(p * freq)) * amp;
        freq *= 2.0;
        amp *= 0.5;
    }
    
    return value;
}

// Physics simulation functions
vec3 applyGravity(vec3 position, vec3 velocity, float mass)
{
    vec3 gravityForce = environment[0].gravity.xyz * environment[0].gravity.w;
    return velocity + gravityForce * pushConstants.deltaTime.x * mass;
}

vec3 applyWind(vec3 position, vec3 velocity, float size)
{
    vec3 windForce = environment[0].wind.xyz * environment[0].wind.w;
    float windEffect = 1.0 / (1.0 + size * 0.1);
    return velocity + windForce * pushConstants.deltaTime.x * windEffect;
}

vec3 applyTemperature(vec3 position, vec3 velocity, float temperature)
{
    vec3 tempEffect = environment[0].temperature.xyz * environment[0].temperature.w;
    float tempInfluence = temperature * 0.01;
    return velocity + tempEffect * pushConstants.deltaTime.x * tempInfluence;
}

vec3 applyHumidity(vec3 position, vec3 velocity, float humidity)
{
    vec3 humidityEffect = environment[0].humidity.xyz * environment[0].humidity.w;
    float humidityInfluence = humidity * 0.01;
    return velocity + humidityEffect * pushConstants.deltaTime.x * humidityInfluence;
}

// Blood physics functions
float calculateCoagulation(float age, float temperature, float viscosity)
{
    float coagulationRate = 0.1;
    float temperatureEffect = 1.0 - abs(temperature - 37.0) * 0.01;
    float viscosityEffect = viscosity * 0.01;
    return age * coagulationRate * temperatureEffect * viscosityEffect;
}

float calculateEvaporation(float age, float temperature, float humidity)
{
    float evaporationRate = 0.05;
    float temperatureEffect = max(0.0, (temperature - 20.0) * 0.01);
    float humidityEffect = 1.0 - humidity * 0.01;
    return age * evaporationRate * temperatureEffect * humidityEffect;
}

float calculateViscosity(float age, float temperature, float coagulation)
{
    float baseViscosity = 1.0;
    float ageEffect = age * 0.01;
    float temperatureEffect = (40.0 - temperature) * 0.01;
    float coagulationEffect = coagulation * 0.1;
    return baseViscosity + ageEffect + temperatureEffect + coagulationEffect;
}

// Color calculation functions
vec3 calculateBloodColor(float age, float temperature, float coagulation, float oxygenation)
{
    vec3 freshBlood = vec3(0.8, 0.1, 0.1);
    vec3 oldBlood = vec3(0.3, 0.05, 0.05);
    vec3 coagulatedBlood = vec3(0.6, 0.08, 0.08);
    vec3 oxygenatedBlood = vec3(0.9, 0.2, 0.2);
    
    float ageFactor = clamp(age * 0.1, 0.0, 1.0);
    float coagulationFactor = clamp(coagulation, 0.0, 1.0);
    float oxygenationFactor = clamp(oxygenation, 0.0, 1.0);
    
    vec3 baseColor = mix(freshBlood, oldBlood, ageFactor);
    baseColor = mix(baseColor, coagulatedBlood, coagulationFactor);
    baseColor = mix(baseColor, oxygenatedBlood, oxygenationFactor);
    
    return baseColor;
}

// Main compute shader function
void main()
{
    uint index = gl_GlobalInvocationID.x;
    
    if (index >= pushConstants.particleCount.x) {
        return;
    }
    
    // Get particle data
    vec3 position = particles[index].position.xyz;
    vec3 velocity = particles[index].velocity.xyz;
    vec4 color = particles[index].color;
    float size = particles[index].size.x;
    vec4 properties = particles[index].properties;
    
    float age = particles[index].position.w;
    float life = particles[index].velocity.w;
    float temperature = properties.x;
    float viscosity = properties.y;
    float coagulation = properties.z;
    float wetness = properties.w;
    
    // Apply physics
    velocity = applyGravity(position, velocity, size);
    velocity = applyWind(position, velocity, size);
    velocity = applyTemperature(position, velocity, temperature);
    velocity = applyHumidity(position, velocity, wetness);
    
    // Update position
    position += velocity * pushConstants.deltaTime.x;
    
    // Update blood properties
    coagulation = calculateCoagulation(age, temperature, viscosity);
    float evaporation = calculateEvaporation(age, temperature, wetness);
    viscosity = calculateViscosity(age, temperature, coagulation);
    wetness = max(0.0, wetness - evaporation * pushConstants.deltaTime.x);
    
    // Update color
    vec3 newColor = calculateBloodColor(age, temperature, coagulation, color.a);
    color = vec4(newColor, color.a);
    
    // Update age and life
    age += pushConstants.deltaTime.x;
    life = max(0.0, life - pushConstants.deltaTime.x * 0.1);
    
    // Store updated particle data
    outputParticles[index].position = vec4(position, age);
    outputParticles[index].velocity = vec4(velocity, life);
    outputParticles[index].color = color;
    outputParticles[index].size = vec4(size, 0.0, 0.0, 0.0);
    outputParticles[index].properties = vec4(temperature, viscosity, coagulation, wetness);
}
